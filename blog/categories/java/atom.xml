<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | EOF]]></title>
  <link href="http://jasonleaster.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://jasonleaster.github.io/"/>
  <updated>2016-10-20T23:36:02+08:00</updated>
  <id>http://jasonleaster.github.io/</id>
  <author>
    <name><![CDATA[Jason Leaster]]></name>
    <email><![CDATA[jasonleaster@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Brief Introduction to the Architecture of JUnit4]]></title>
    <link href="http://jasonleaster.github.io/blog/2016/09/11/the-brief-introduction-to-the-archtecture-of-junit4/"/>
    <updated>2016-09-11T15:44:46+08:00</updated>
    <id>http://jasonleaster.github.io/blog/2016/09/11/the-brief-introduction-to-the-archtecture-of-junit4</id>
    <content type="html"><![CDATA[<p>JUnit is a good framework for developer to finish testing tasks. 
I also use JUnit to help me with testing. From the perspective of a good 
programmer, the source code of JUnit is also a wonderful example to learn
how to write more good style code in Java.</p>

<p>In this article, I would like to try my best to share my view of JUnit.
The version of JUnit what I talked is JUnit4 in this article.</p>

<h3 id="how-junit-start-to-run">How JUnit start to run?</h3>

<p>Most Java developers work under the IDE like eclipse, Intellij IDEA and so on. It’s no doubt that the success of Java can’t without the development of IDE in this years.
But there also will be a satire that some Java programmer just use this framework and have no idea about how it works.</p>

<p>Here is a simple demo for how to use JUnit to test your program.</p>

<p>``` Java</p>

<p>// MyTest.java
package org.junit;</p>

<p>public class MyTest {
    @Before
    public void before(){
        System.out.println(“before”);
    }</p>

<pre><code>@Test
public void testFunc(){
    System.out.println("testFunc");
}

@After
public void after(){
    System.out.println("after");
} }
</code></pre>

<p>```</p>

<p>I referenced the point of someone’s view about Java programmer.</p>

<blockquote>
  <p>“They press down the green buttion in their IDE, and the testing program just run. There even does’t show a main() function in their testing program. They also don’t think why it works and how it can run successfully? Why java program can run without a main() function? It’s a magic? No, please think more deeply and don’t make your self look like an innocent beginner.”</p>
</blockquote>

<p>With the help of IDE and framework, it’s more and more easy for the developer to finish their project. 
It <strong>DO</strong> help the developer to accelerate the process to finish a project. It also hide some basical information about how program start to run.</p>

<p>With the IDE, you still a programmer but not a magician :)</p>

<ul>
  <li>Why <code>MyTest.java</code> could run without main() function?</li>
  <li>Why the program will run with just pressing the button in your IDE?</li>
</ul>

<p><img src="http://jasonleaster.github.io/images/img_for_2016_09/IntellijJUnitCallFrame.jpg" align="middle" /></p>

<p>The reason is that IDE will integrated with some plugin. Some GUI button are corelated with that plugin.(Eg. Intellij IDEA have a junit-plugin for JUnit Framework). After you press the button, the plugin start to run and it will call the entrance of the framework for you. You can see that in the image, the first function called by java is <code>JUnitStarter</code> which is on package <code>com.intellij</code>. Finally, it will enter in <code>org.junit</code> which is the JUnit framework package.</p>

<p>You can also see the output of the console in your IDE. You can find that there is commands like this:</p>

<p>```</p>

<pre><code>D:\JAVA_ENV\jdk1.8\bin\java -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:58641,suspend=y,server=n -ea -Dfile.encoding=GBK -classpath "D:\IntelliJ IDEA\lib\idea_rt.jar;    ... A LOT OF JAR ...     E:\Java Framework Source\junit4-master\out\production\main" com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 org.junit.MyTest
</code></pre>

<p>```</p>

<p>For simplicity, the commands over there can be simplied into the below procesure under the CMD or Linux-Shell.</p>

<p>```
Compile:
    javac -cp path/to/testclasses:path/to/junit-4.8.2.jar MyTest.java</p>

<p>Run:
    java  -cp path/to/testclasses:path/to/junit-4.8.2.jar org.junit.JUnitCore org.junit.MyTest</p>

<p>```</p>

<p>Now, the answer is clear that IDE just use a plugin to call the entrance of the framework instead of calling it by yourself under the OS console.</p>

<p>If you use <code>JUnitCore</code> to run your test, <code>JUnitCore</code> then uses reflection to find an appropriate Runner for the passed test classes. One step here is to look for a @RunWith annotation on the test class. If no other Runner is found the default runner (BlockJUnit4ClassRunner) will be used. The Runner will be instantiated and the test class will be passed to the Runner. Now it is Job of the Runner to instantiate and run the passed test class.</p>

<p>Let’s start to look the architecture of the JUnit Framework.</p>

<h3 id="the-high-level-view-of-junit">The high level view of JUnit</h3>

<p>There are two main abstract model for JUnit framework. The one of it is the abstraction of test unit.
Each test unit has its own scope, name, initial state and the way how to release the resouces which are allocated during the testing time.</p>

<p>For JUnit4, it use this inheritance model to represent that concept.</p>

<p>Review the skeleton of <code>MyTest.java</code>, the test routine is around the test class. Here is the class <code>MyTest</code>.</p>

<p>``` Java</p>

<p>// MyTest.java
package org.junit;
…
    @Test
    public void testFunc(){
        System.out.println(“testFunc”);
    }
…</p>

<p>```</p>

<p><img src="/images/img_for_2016_09/JUnitInheritance2.jpg" alt="images" /></p>

<p>With the annotation, the framework use the reflection to get the meta-information of the test unit.</p>

<p>A class has it’s own member so JUnit use abstract class <code>FrameworkMember</code> to represent it. 
Class member can be classify into <code>field</code> and <code>method</code>.
So JUnit use class <code>FrameworkFiled</code> and <code>FrameworkMethod</code> which inherite from <code>FrameworkMember</code>.</p>

<p>``` java</p>

<p>class FrameworkField extends FrameworkMember<frameworkfield> {
        private final Field field;</frameworkfield></p>

<pre><code>    ... ... }
</code></pre>

<p>/**
 * Represents a method on a test class to be invoked at the appropriate point in
 * test execution. These methods are usually marked with an annotation (such as
 * {@code @Test}, {@code @Before}, {@code @After}, {@code @BeforeClass},
 * {@code @AfterClass}, etc.)
 *
 * @since 4.5
 */
public class FrameworkMethod extends FrameworkMember<frameworkmethod> {
        private final Method method;</frameworkmethod></p>

<pre><code>    ... ... }
</code></pre>

<p>```</p>

<p><code>FrameworkField</code> maintain a private object of class <code>Field</code> which is used in <strong>reflection</strong>. So do <code>FrameworkMethod</code>.</p>

<p>JUnit tests are started using the <code>JUnitCore</code> class. It will can runners to finish the task.
The other important heritance show below there.</p>

<p><img src="/images/img_for_2016_09/JUnitInheritance1.jpg" alt="images" /></p>

<p>The <code>public class AllDefaultPossibilitiesBuilder extends RunnerBuilder </code>will be called and try to find a runner to run the test class which is written by user.</p>

<p>Finally, <code>BlockJUnit4ClassRunner</code> will be called.</p>

<p>``` java</p>

<p>/**
 * Implements the JUnit 4 standard test case class model, as defined by th
 * annotations in the org.junit package.</p>

<ul>
  <li>It has a much simpler implementation based on {@link Statement}s,</li>
  <li>allowing new operations to be inserted into the appropriate point in the</li>
  <li>execution flow.
 */</li>
</ul>

<p>public class BlockJUnit4ClassRunner extends ParentRunner<frameworkmethod> {</frameworkmethod></p>

<pre><code>private final ConcurrentMap&lt;FrameworkMethod, Description&gt; methodDescriptions = new ConcurrentHashMap&lt;FrameworkMethod, Description&gt;();

... ...

@Override
protected List&lt;FrameworkMethod&gt; getChildren() {
    // scan test class for methonds annotated with @Test
}
   
@Override
protected Description describeChild(FrameworkMethod method) {
    // create Description based on method name
}
     
@Override
protected void runChild(final FrameworkMethod method, RunNotifier notifier) {
    if (/* method not annotated with @Ignore */) {                  
        // run methods annotated with @Before
        // run test method
        // run methods annotated with @After
    }
}

... ... }
</code></pre>

<p>```</p>

<h3 id="summary">Summary</h3>

<p>Reference: 
1. http://www.mscharhag.com/java/understanding-junits-runner-architecture</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Great Ideas in Object Oriented Programming]]></title>
    <link href="http://jasonleaster.github.io/blog/2016/06/14/great-ideas-in-object-oriented-programming/"/>
    <updated>2016-06-14T12:49:00+08:00</updated>
    <id>http://jasonleaster.github.io/blog/2016/06/14/great-ideas-in-object-oriented-programming</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#encapsulation" id="markdown-toc-encapsulation">Encapsulation</a></li>
  <li><a href="#composition-inheritance-and-delegation" id="markdown-toc-composition-inheritance-and-delegation">Composition, inheritance, and delegation</a>    <ul>
      <li><a href="#warning-of-using-inheritance" id="markdown-toc-warning-of-using-inheritance">Warning of using inheritance</a></li>
    </ul>
  </li>
  <li><a href="#polymophsim" id="markdown-toc-polymophsim">Polymophsim</a></li>
  <li><a href="#oop-design" id="markdown-toc-oop-design">OOP Design</a></li>
</ul>

<blockquote>
  <p>Object-oriented programming (OOP) is a programming paradigm based on the concept of “objects”, which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. – <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">Wikipedia</a></p>
</blockquote>

<p>OOP is just a programming paradigm and it helps programmer to build more robust and implement more abstract concept which are needed in their project.OOP isn’t the treasure which only belongs to a special programming language. It offer a way to make the problem more easy to be understood and to be solved.</p>

<p>There are three gread ideas in OOP.</p>

<ul>
  <li>Encapsulation</li>
  <li>Composition, inheritance, and delegation</li>
  <li>Polymophsim</li>
</ul>

<!-- more -->

<h3 id="encapsulation">Encapsulation</h3>

<p>The most basic idea in OOP is that each object encapsulates some data and code. The object takes requests from other client object. The object alone is responsible for its own state, exposing public message for clients, and declaring private the variables and the methods. The client depends on the simple public interface, and does not known about or depend on the details of the implementation.</p>

<p><strong>Encapsulation remind us to put details and complexity into a black box. The outside people(user) don’t need to care about how this box was built but just use it with the instructions which the box suppled.</strong></p>

<p>Q: What if we want to implement a abstract concept in mathematic – Point.</p>

<p>Point, the most basic presentation of point is two coordinates in Descartes coordinate system(x, y). How to implement it with program ?</p>

<p>Consider the following implementation in java.</p>

<p>``` java</p>

<p>[MyPoint1.java]</p>

<p>public class MyPoint1 {
    public int x;   // x and y are public
    public int y;</p>

<pre><code>public MyPoint1(int x,int y) {
    this.x = x;
    this.y = y;
}

// Client Code
public static void main(String[] args){

    MyPoint1 p = new MyPoint1(1, 2);

    /**
     * Bad style to try to use the detail information of a class.
     * Here, client programmer should not use data member of the class directly.
     * With the software iteration and release the library which implement the
     * class which have used in your project. You may have to rewrite all your
     * client program. Because the author of that library may change the implementation
     * of that class and your code can't be used with the new library.
     */
    int z = p.x + p.y;// !! Bad style.

    System.out.print(z);
} }
</code></pre>

<p>```</p>

<p>Here all information is public, this is the most convenient for end users, but limits our ability to change things later in development. What would happend if you build a software and you find something should be changed with the implementation of <code>MyPoint1</code>. You may want to add more attributes into this class. You may also want to rewrite your code and change it into another coordinate system but not descartes coordinate system.</p>

<p>If the others module depends on your implementation of <code>MyPoints1</code> and use the data member of that class directly, you may have to rewrite your whole project and it will cost your a lot of time. It will be nightmare for programmer to be told “Hey, buddy. There is something changed with requirement, you have to rewrite your whole project. Just put the code into garbage collector. It can’t be modified to satisfy the new requirement.”</p>

<p><img src="/images/img_for_2016_06_14/wth.png" alt="images" /></p>

<p>Here is a bettern one solution. In <code>MyPoint2</code>, the detail of this class are setted as private which means that the client(user) can’t use the information about the implementation directly. The only way that the user can use the information which they need is to use the interface that the class supply with. In this example, the interface which public can access is <em>getX()</em>  and <em>getY()</em> .</p>

<p>``` java</p>

<p>[MyPoint2.java]
public class MyPoint2 {</p>

<pre><code>private int x;  // x and y are private

private int y;
            
public MyPoint2(int x,int y) {
    this.x = x;
    this.y = y;
}

public int getX() {
    return x;
}

public int getY() {
    return y;
}

// Client Code
public static void main(String[] args){
    MyPoint2 p = new MyPoint2(1, 2);
    int z = p.getX() + p.getY(); // Good Style :)
    System.out.print(z);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>The advantage of accessing control and encapsulation is that we can replace the current implementation into another better one and make sure the client don’t need to be modified for this changes in the original class(MyPoint2).</p>

<p>Here, we implement Point with polar coordinate system. All the interface that set as public in <code>MyPoint2</code> are unchanged. This make sure that the client which use <code>getX()</code> and <code>getY()</code> don’t need to be modified for changes with the implementation of Point.</p>

<p>``` java</p>

<p>[MyPoint3.java]
public class MyPoint3 {
    private double r;
    private double theta;</p>

<pre><code>public MyPoint3(int x,int y) {
    this.r = Math.sqrt(x * x + y * y);
    theta = Math.atan( (double) y / x);
}
                
public long getX() {
    return Math.round(r * Math.cos(theta));
}
                    
public long getY() {
    return Math.round(r * Math.sin(theta));
}

/**
 * Client Code don't need to be modified after the implemetation of Point changed
 */
public static void main(String[] args){
    MyPoint2 p = new MyPoint2(1, 2);
    int z = p.getX() + p.getY(); // Good Style :)
    System.out.print(z);
}
</code></pre>

<p>}</p>

<p>```</p>

<h3 id="composition-inheritance-and-delegation">Composition, inheritance, and delegation</h3>

<p>In object-oriented programming, inheritance is when an object or class is based on another object (prototypal inheritance) or class (class-based inheritance), using the same implementation (inheriting from an object or class) specifying implementation to maintain the same behavior (realizing an interface; inheriting behavior). In this ariticle, we only talk about the class-based inheritance.</p>

<p>What’s the adavantages of inheritance ?</p>

<ul>
  <li>Overriding</li>
  <li>Code Reuse</li>
</ul>

<p>Many OOP programming language permit to replace the implementation of one or more method that it inherited from the base class. We call this feature as <strong>Overriding</strong>. There are two way to help us to reuse code. The one way is composition and the other way is inheritance.</p>

<p>You reuse code by creating new classes, but instead of creating them from scratch, you use existing classes that someone has already built and debugged.</p>

<p>In Java and Python (I don’t know the implementation of C++), you always doing inheritance when you create an object.</p>

<blockquote>
  <p>Class Object is the root of the class hierarchy. Every class has Object as a superclass. All objects, including arrays, implement the methods of this class.            Since: JDK1.0   – <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html">Java Doc notes</a></p>
</blockquote>

<p>You could also read my article about <a href="http://jasonleaster.github.io/blog/2015/06/13/memory-model-of-objects-in-c-plus-plus/">Moemory Model of Object in C++</a> and <a href="http://jasonleaster.github.io/blog/2016/02/03/memory-model-of-int-object-in-python/">In Object In Python</a>. If you are interesting in the implementation of inheritance, just read all about it.</p>

<h4 id="warning-of-using-inheritance">Warning of using inheritance</h4>

<p>In heritance is a clever and appealing techonology, it is best applied in somewhat rare circumstances where you have several deeply similar classes. It’s a common error for beginning OOP programmers to try to use inheritance for everything. In constrat, application of modularity and encapsulation and API design may be less flashy, but they are incredibly common and powerful.</p>

<h3 id="polymophsim">Polymophsim</h3>

<h3 id="oop-design">OOP Design</h3>
]]></content>
  </entry>
  
</feed>
