<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | EOF]]></title>
  <link href="http://jasonleaster.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://jasonleaster.github.io/"/>
  <updated>2016-02-19T23:28:46+08:00</updated>
  <id>http://jasonleaster.github.io/</id>
  <author>
    <name><![CDATA[Jason Leaster]]></name>
    <email><![CDATA[jasonleaster@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Web Crawler]]></title>
    <link href="http://jasonleaster.github.io/blog/2016/02/19/web-crawler/"/>
    <updated>2016-02-19T21:27:47+08:00</updated>
    <id>http://jasonleaster.github.io/blog/2016/02/19/web-crawler</id>
    <content type="html"><![CDATA[<table>
  <tbody>
    <tr>
      <td>Finished my first web scrawler … =_=</td>
    </tr>
  </tbody>
</table>

<p>Here is all about the spider. It’s small but funny.</p>

<p>After I finish this web scrawler, I learn that. The most important thing to build a web scrawler is not the code but the inverse process. How to build your program like a web browser.</p>

<p>Static web page is easy to get but how about a dynamic web page. Nowadays, more and more website use <code>ajax</code> to meet their bussiness requirement. If you just send a simple request to the server of that web site, you will find than the returned page is just only part of the total user page that you saw in the web browser.</p>

<p>Here is my demonstration.
<a href="www.duitang.com">duitang.com</a> is a funny images web site. I love a cute virtual character who is named as Mr.zhangcao . There is a lot of images of that guy. So I want build a web crawler to get that images all.</p>

<p>If you send a request to the <a href="http://www.duitang.com/album/56759353">main page</a> and anlysis the returned page (Python’s library <strong>BeautifulSoup</strong> is helpful to analysis html files), you will find there are some links in the html file. But you will only get about 20+ images but not all images that you viewed in the web browser. When you pull down the button of the brower, you will see more and more images coming out to user.</p>

<p>Why the returned page don’t have all links of images? The answer is <code>ajax</code>(asynchronous JavaScript and XML) is a set of web development techniques using many web technologies on the client-side to create asynchronous Web application.</p>

<p><strong>The monitor in browswer will help programmer who is writing a web spider.</strong></p>

<p>Dig into the detail of http transport, you will find a special request which are sent to server by the client browser.</p>

<p>This is that special url.</p>

<p>``` python</p>

<p>http://www.duitang.com/napi/blog/list/by_album/?album_id=
&amp;limit=24
&amp;include_fields=top_comments%2Cis_root%2Csource_link%2Cbuyable%2Croot_id%2C
status%2Clike_count%2Csender%2Creply_count&amp;start=48&amp;_=1455881387791</p>

<p>```</p>

<p>If client request that url to the server, the server will return a json data object. The job left is to analysis the json object and then get the resource links.</p>

<p>The important part of building a web crawler is not the code but how to find the useful url and get more useful information.</p>

<p>Here is a screenshut for what my web scrawler got.
<img src="/images/img_for_2016_02_19/screenshut.png" alt="images" /></p>

<p>``` python</p>

<p>”””
Programmer 	: EOF
E-mail 		: jasonleaster@163.com
File        : duitang.py
Date        : 2016.02.19</p>

<p>”””
#!/usr/bin/env python
# -<em>- coding: utf-8 -</em>-</p>

<p>import urllib
import urllib2
import json
import re
import time</p>

<p>downloadCount = 0</p>

<p>album_id = 72129639
limit = 100
start = 1</p>

<h1 id="this-function-return-a-url-and-this-url-will-return-a-json-object-data">This function return a URL and this URL will return a json object data.</h1>
<p>def duitangURLMaker(album_id, limit, start):
    url_part_1 = “http://www.duitang.com/napi/blog/list/by_album/?album_id=”
    url_part_2 = “&amp;limit=”
    url_part_3 = “&amp;include_fields=top_comments%2Cis_root%2Csource_link%2Cbuyable%2Croot_id%2Cstatus%2Clike_count%2Csender%2Creply_count&amp;start=”
    url_part_4 = “&amp;_=1455881387791”</p>

<pre><code>URL = url_part_1 + str(album_id) + url_part_2 + str(limit) + url_part_3 + str(start) + url_part_4

return URL
</code></pre>

<p>def imgURLs(jsonDict):
	URLs = []
	object_list = jsonDict[“data”][“object_list”]
	for item in object_list:
		URLs.append(item[“photo”][“path”])</p>

<pre><code>return URLs
</code></pre>

<p>URL 		= duitangURLMaker(album_id, limit, start)
string 		= urllib.urlopen(URL).read()
jsonDict 	= json.loads(string)</p>

<p>URLs = imgURLs(jsonDict)</p>

<p>for url in URLs:
    Filename = “duitang_%s.jpeg” % (downloadCount)
    try:
        urllib.urlretrieve(url, Filename)
        print “Download from”, url
        downloadCount += 1
    except:
        print “Analyse Failed”</p>

<p>```</p>

<hr />
<p>Photo by Jason Leaster. LiuYe Lake in ChangDe, HuNan, China.
<img src="/images/img_for_2016_02_19/liuyehu.jpg" alt="images" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Brief Introduction to Opcodes in Python]]></title>
    <link href="http://jasonleaster.github.io/blog/2016/02/06/brief-introduction-to-opcodes-in-python/"/>
    <updated>2016-02-06T18:39:50+08:00</updated>
    <id>http://jasonleaster.github.io/blog/2016/02/06/brief-introduction-to-opcodes-in-python</id>
    <content type="html"><![CDATA[<p>Python program is compiled down to bytecode which is sort of like assembly for the python virtual machine. The interpreter executes each of these bytecodes one by one.</p>

<p>Let’s look the following code. It’s easy to understand what it is doing without my explanation.</p>

<p>``` python</p>

<p>[demo.py]</p>

<p>x = 1
y = 2
z = x + y
print “x, y, z”, x, y, z</p>

<p>```
<!-- more --></p>

<p>Programmer can use python module <code>dis</code> to transform that code into the assemble program of Python.</p>

<p>``` python</p>

<p>python -m dis “./demo.py”
#line number 
#in the       #assemble code           # object name in the source code
#source code
1           0 LOAD_CONST               0 (1)
            3 STORE_NAME               0 (x)</p>

<p>2           6 LOAD_CONST               1 (2)
            9 STORE_NAME               1 (y)</p>

<p>3          12 LOAD_NAME                0 (x)
           15 LOAD_NAME                1 (y)
           18 BINARY_ADD
           19 STORE_NAME               2 (z)</p>

<p>4          22 LOAD_NAME                0 (x)
           25 PRINT_ITEM
           26 LOAD_NAME                1 (y)
           29 PRINT_ITEM
           30 LOAD_NAME                2 (z)
           33 PRINT_ITEM
           34 PRINT_NEWLINE
           35 LOAD_CONST               2 (None)
           38 RETURN_VALUE</p>

<h6 id="section">#</h6>

<p>”””
In the interpreter of Python, programmer also can call
the built-in function @compile and import module @dis
to do the same thing.
“””</p>

<p>In [5]: source = open(“./hello.py”).read()</p>

<p>In [6]: code = compile(source, “demo”, “exec”)</p>

<p>In [7]: import dis</p>

<p>In [8]: dis.dis(code)</p>

<p>```</p>

<p>It’s not hard to understand the <code>opcode</code>. In implementation of CPython, all opcode defined as Macro in the header file <code>Include/opcode.h</code>.</p>

<p>``` C</p>

<p>[Include/opcode.h]
…
#define LOAD_CONST  100 /* Index in const list <em>/
#define LOAD_NAME   101 /</em> Index in name list */
…</p>

<p>```</p>

<p>The evaluation machine of Python is a stack-based machine.
If you find the detail of <code>18 BINARY_ADD</code>, you will find that this opcode 
will pop the two object on the stack and then add them together.</p>

<p>``` C</p>

<p>[Python/ceval.c]
…</p>

<p>/* Stack manipulation macros */</p>

<p>/* The stack can grow at most MAXINT deep, as co_nlocals and
      co_stacksize are ints. */</p>

<h1 id="define-stacklevel-----intstackpointer---f-fvaluestack">define STACK_LEVEL()     ((int)(stack_pointer - f-&gt;f_valuestack))</h1>
<p>#define EMPTY()           (STACK_LEVEL() == 0)
#define TOP()             (stack_pointer[-1])
#define SECOND()          (stack_pointer[-2])
#define THIRD()           (stack_pointer[-3])
#define FOURTH()          (stack_pointer[-4])
#define PEEK(n)           (stack_pointer[-(n)])
#define SET_TOP(v)        (stack_pointer[-1] = (v))
#define SET_SECOND(v)     (stack_pointer[-2] = (v))
#define SET_THIRD(v)      (stack_pointer[-3] = (v))
#define SET_FOURTH(v)     (stack_pointer[-4] = (v))
#define SET_VALUE(n, v)   (stack_pointer[-(n)] = (v))
#define BASIC_STACKADJ(n) (stack_pointer += n)
#define BASIC_PUSH(v)     (<em>stack_pointer++ = (v))
#define BASIC_POP()       (</em>–stack_pointer)
…</p>

<p>```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functional Programming in Python]]></title>
    <link href="http://jasonleaster.github.io/blog/2016/02/05/functional-programming-in-python/"/>
    <updated>2016-02-05T02:37:57+08:00</updated>
    <id>http://jasonleaster.github.io/blog/2016/02/05/functional-programming-in-python</id>
    <content type="html"><![CDATA[<p>Functional programming is not only use functions.
Think of “y = f(x)” or “h = f * g”</p>

<p>For comparasion, there are different paradigms in programming.</p>

<ul>
  <li>Structured/Procedural – Functions, loops, conditions</li>
  <li>Object-Oriented Programming (OOP) – Classes, objects, methods</li>
  <li>Functional Programming – Decorators, comprehensions, and generators</li>
  <li>Logic Programming</li>
</ul>

<p>Functions in Python are <code>first class value</code>. It can take functions as arguments and return functions like a value.</p>

<p>``` python</p>

<p>”””
function @calc take @f as an argument and use it as a function.
Something like function pointer in C.
“””
def calc(f, x, y):
    return f(x, y)</p>

<p>def add(x, y):
    return x + y</p>

<p>def sub(x, y):
    return x - y</p>

<p>calc(add, 10, 20)</p>

<p>```</p>

<!-- more -->

<p>In Python, there have anonymous functions which is called <code>Lambda Expression</code> which’s body is limited to one expression.</p>

<p>``` python</p>

<p>def calc(f, x, y):
    return f(x, y)</p>

<p>calc(lambda x, y: x + y, 10, 20)</p>

<p>```</p>

<p>Here, lambda expression used as a argument which is passed into function <code>calc</code>. Function like <code>add</code> and <code>sub</code>, they are too short and don’t need a special name to be identified. So, Python support a mechanism – anonymous function which is called <code>Lambda Expression</code>.</p>

<p>There is a another demo. We will change the code from procedure oriented into functional style.</p>

<p>``` python</p>

<p>”””
In a procedure way.
“””
def incr(x):
    return x + 1</p>

<p>def increment_each(elements):
    results = []
    for elem in elements:
        results.append(incr(elem))
    return results</p>

<p>increment_each([1, 2, 3])
# -&gt; [2, 3, 4]</p>

<p>”””
In a functional way.
“””
map(incr, [1, 2, 3])
# or
map(lambda x: x + 1, [1, 2, 3])</p>

<h1 id="if-we-want-to-get-the-length-of-each-element-in-a-iterable-object">if we want to get the length of each element in a iterable object</h1>
<p>map(len, iterable_object)</p>

<p>```</p>

<p><code>filter</code> is a related idea in functional tools like map.
<code>filter</code> return a new sequence where values are taken from the given sequence if they return True when passed to a given function.</p>

<p>``` python</p>

<p>filter(lambda x: x % 2 == 0, [1, 2, 3, 4])
# -&gt; [2, 4]</p>

<p>```</p>

<p><code>reduce</code> will accumulate and return a single result, given a sequence
and passing each value to a function along with the current result.</p>

<p>``` python</p>

<p>from functools import reduce
reduce(lambda accum, current: accum + current, [1, 2, 3], 0)
# -&gt; 6</p>

<p>```</p>

<h3 id="decorator">Decorator</h3>

<p>In Python, function is first-class value and can be used as returned value.
So, programmer can define nested functions in Python like this:</p>

<p>``` python</p>

<p>”””
Nested function
“””
def outer():
    def inner():
        print “I am the inner function”</p>

<pre><code>return inner
</code></pre>

<p>func = outer()</p>

<p>func()
# -&gt; I am the inner function</p>

<p>”””
Closure
“””
def outer(var = 10):</p>

<pre><code>"Local scope of function @outer"

 def inner(number):
     print "I am the inner function!"
     """
     You can't change value of variable once the
     @outer function finished. You will get error
     if you modify variable which is not in scope
     of function @inner. You can't modify @var
     like this: var += 1 (You will get exception
     information like "UnboundLocalError")
     """
     return var + number

return inner
</code></pre>

<p>func = outer(10)</p>

<p>func(90)
# -&gt; 100</p>

<p>```</p>

<p>Look the demo below there.</p>

<p>``` python</p>

<p>def wrapper(func):
    def cheker(arguments_of_func):
        “””
            @checker receive the same arguments as @func
            and do something that @func didn’t do.
        “””
        return new_retVal</p>

<pre><code>return checker
</code></pre>

<p>```</p>

<p>Actually, the reture value of <code>wrapper</code> is a function just little different from the original function passed into <code>wrapper</code> – <code>func</code>. Function <code>wrapper</code> like a shell on the original function and return with a more powerful function. That’s decorator. <code>wrapper</code> is a decorator.</p>

<p><strong>Decorator: A decorator is any callable Python object that is used to modify a function, method or class definition. A decorator is passed th original object being defined and returns a modified object, which is then bound to the name in the definition. Python decorators were inspired in part by Java annotations, and have a similar syntax; teh decorator syntax is pure syntactic sugar, using @ as the keyword               – Wikipedia</strong></p>

<p>Here is a more generic decorators</p>

<p>``` python</p>

<p>def wrapper(func):
    def inner(<em>args, **kwargs)
        print “Show arguments: %s, %s” % (args, kwargs)
        return func(</em>args, **kwargs)
    return inner</p>

<p>@wrapper
def adder(x, y)
    return x + y</p>

<p>print adder(10, 90)</p>

<h1 id="show-arguments-10-90-">-&gt; Show arguments: (10, 90), {}</h1>
<p>#   100</p>

<p>```</p>

<p>A better and more detailed explaination reader could read the blog
<a href="http://www.simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/">Understanding Python Decoratos in 12 Easy Steps!</a>
which is written by <code>simeon franklin</code>.</p>

<h3 id="generator">Generator</h3>

<p>A <code>generator</code> is a special type of iterator(not vice versa!). 
Generator is a factory that lazily produces values.</p>

<p>There are two types of generators in Python: generator functions and generator expression.</p>

<p>``` python</p>

<p>”””
Demo for generator
“””</p>

<p>def fib():
    prev, curr = 0, 1
    while True:
        “””
            There is no @return keyword in generator,
        but there must be a @yield with a return object 
        if there is a  generator function.
        “””
        yield curr 
        prev, curr = curr, prev + curr</p>

<p>f = fib()
f.next()</p>

<h6 id="section">#</h6>

<p>”””
Generator Expression
“””
numbers = [1, 2, 3, 4, 5, 6]</p>

<p>lazy_square = ( x * x for x in numbers)
“””
Type:        generator
String form: &lt;generator object <genexpr> at 0x7fd3bc119fa0&gt;
Docstring:   <no docstring="">
"""</no></genexpr></p>

<p>In [18]: lazy_square == list
Out[18]: False</p>

<p>In [19]: lazy_square
Out[19]: &lt;generator object <genexpr> at 0x7fd3bc0da410&gt;</genexpr></p>

<p>In [20]: lazy_square.next()
Out[20]: 1</p>

<p>In [21]: lazy_square.next()
Out[21]: 4</p>

<p>In [22]: lazy_square.next()
Out[22]: 9</p>

<p>```</p>

<hr />
<p>Photo by Jason Leaster in ChangDe, HuNan, China.</p>

<p>What a big banana :)</p>

<p><img src="/images/img_for_2016_02_06/banana.png" alt="images" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dict Object in Python]]></title>
    <link href="http://jasonleaster.github.io/blog/2016/02/04/dict-object-in-python/"/>
    <updated>2016-02-04T12:54:11+08:00</updated>
    <id>http://jasonleaster.github.io/blog/2016/02/04/dict-object-in-python</id>
    <content type="html"><![CDATA[<p>Dictionary object type – mapping from hashable object to object</p>

<p>In the implemenation, Python don’t choose <code>Red-Black Tree</code> as the basic data structure but Hash Table with a special technology – <code>Open Addressing</code>.</p>

<p>About open addressing:</p>

<blockquote>
  <p>In computer science, lazy deletion refers to a method of deleting elements from a hash table that uses open addressing. In this method, deletions are done by marking an element as deleted, rather than erasing it entirely. Deleted locations are treated as empty when inserting and as occupied during a search. – Wikipedia</p>
</blockquote>

<!-- more -->

<p>There three kinds of slots in the table:</p>

<ol>
  <li>
    <p>Unused.  <code>me_key</code> == <code>me_value</code> == <code>NULL</code>
Does not hold an active (key, value) pair now and never did.  Unused can transition to Active upon key insertion.  This is the only case in which <code>me_key</code> is NULL, and is each slot’s initial state.</p>
  </li>
  <li>
    <p>Active.  <code>me_key</code> != NULL and <code>me_key</code> != dummy and <code>me_value</code> != NULL Holds an active (key, value) pair.  Active can transition to Dummy upon key deletion.  This is the only case in which <code>me_value</code> != NULL.</p>
  </li>
  <li>
    <p>Dummy.  <code>me_key</code> == dummy and <code>me_value</code> == NULL
Previously held an active (key, value) pair, but that was deleted and an active pair has not yet overwritten the slot.  Dummy can transition to Active upon key insertion. Dummy slots cannot be made Unused again (cannot have <code>me_key</code> set to NULL), else the probe sequence in case of collision would have no way to know they were once active.</p>
  </li>
</ol>

<p>Here, Python define the entry data type of dict in python <code>PyDictObejct</code>. A entry is like a paire (key, value). To avoid calculating the hash value of <code>me_key</code>, <code>me_hash</code> used as a cached value for it.</p>

<p>``` C</p>

<p>[Include/dictobject.h]
typedef struct {
    Py_ssize_t me_hash;
    PyObject *me_key;
    PyObject *me_value;
} PyDictEntry;</p>

<p>```</p>

<p>To ensure the lookup algorithm terminates, there must be at least one Unused slot (NULL key) in the table.</p>

<p>The value <code>ma_fill</code> is the number of non-NULL keys (sum of Active and Dummy);
   <code>ma_used</code> is the number of non-NULL, non-dummy keys (== the number of non-NULL values == the number of Active items).
   To avoid slowing down lookups on a near-full table, we resize the table when it’s <font color="red">two-thirds</font> full.</p>

<p>``` C</p>

<p>[Include/dictobject.h]
typedef struct _dictobject PyDictObject;
struct _dictobject {
    PyObject_HEAD
    Py_ssize_t ma_fill;  /* # Active + # Dummy <em>/
    Py_ssize_t ma_used;  /</em> # Active <em>/
    /</em> The table contains ma_mask + 1 slots, and that’s a power of 2.
     * We store the mask instead of the size because the mask is more
     * frequently needed.
     */
    Py_ssize_t ma_mask;</p>

<pre><code> */
PyDictEntry *ma_table;
PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
PyDictEntry ma_smalltable[PyDict_MINSIZE]; };
</code></pre>

<p>```</p>

<p><code>PyDict_MINSIZE</code> is the minimum size of a dictionary.  This many slots are allocated directly in the dict object.
(in the <code>ma_smalltable</code> member). 
It must be a power of 2, and at least 4.  8 allows dicts with no more than 5 active entries to live in <code>ma_smalltable</code> (and so avoid an additional malloc); instrumentation suggested this suffices for the majority of dicts (consisting mostly of usually-small instance dicts and usually-small dicts created to pass keyword arguments).</p>

<p>``` C</p>

<h1 id="define-pydictminsize-8">define PyDict_MINSIZE 8</h1>

<p>```</p>

<p>Here defined a array <code>ma_smalltable</code> which store 8 <code>PyDictEntry</code>.
<code>ma_table</code> points to <code>ma_smalltable</code> for small tables, else to 
additional malloc’ed memory.  <code>ma_table</code> is never NULL!<br />
This rule saves repeated runtime null-tests in the workhorse getitem and setitem calls.</p>

<p>I draw a figure to make the idea easy to be understand.</p>

<p><img src="/images/img_for_2016_02_04/dictTable.png" alt="images" /></p>

<p>The question is coming. When Python will resize the diction table of that object?</p>

<p>The answer is in function <code>dictresize</code> in file <code>Object/dictobject.c</code></p>

<p>``` C
[Object/dictobject.c]
…</p>

<p>// Recall the rule of 2/3 –notes by Jason Leaster
if (!(mp-&gt;ma_used &gt; n_used &amp;&amp; mp-&gt;ma_fill<em>3 &gt;= (mp-&gt;ma_mask+1)</em>2)) 
        return 0;</p>

<pre><code>// Debug information add by Jason Leaster
printf("Try to resize the old diction\n");
printf("mp-&gt;ma_used  :%p \n", mp-&gt;ma_used);
printf("mp-&gt;ma_fill  :%p \n", mp-&gt;ma_fill);
                    
return dictresize(mp, (mp-&gt;ma_used &gt; 50000 ? 2 : 4) * mp-&gt;ma_used); }   
</code></pre>

<p>```</p>

<p>Attention, once <code>mp-ma_fill</code> bigger or equal to (2/3)<code>mp-&gt;ma_mask+1</code> and we have finished a insert operation(<code>mp-&gt;ma_used</code> &gt; <code>n_used</code>), <strong>we should resize the container(ma_table) of  the dictionary</strong>.</p>

<p>Yes, we should resize the dictionary object if there have 6 or more object in the container but <strong>not</strong> 8.</p>

<p>Here is the result of hacking.</p>

<p><img src="/images/img_for_2016_02_04/testResizeDict.png" alt="images" /></p>

<p>Actually, <code>dummy</code> PyDictObject is just a <code>PyStringObject</code> in Python. Initially, dummy is a pointer in C but it finally comes to a <code>PyStringObject</code> after initialization of <code>PyDictObject</code> first time.</p>

<p>``` C</p>

<p>/* Object used as dummy key to fill deleted entries <em>/
static PyObject *dummy = NULL; /</em> Initialized by first call to newPyDictObject() */</p>

<p>```</p>

<h3 id="initialization-part">Initialization Part</h3>

<p>There are two ways to create a dict:  <code>PyDict_New()</code> is the main C API function, 
and the <code>tp_new</code> slot maps to <code>dict_new()</code>.  In the latter case we
    can save a little time over what PyDict_New does because it’s guaranteed
    that the PyDictObject struct is already zeroed out.
    Everyone except dict_new() should use EMPTY_TO_MINSIZE (unless they have an excellent reason not to).</p>

<p>``` C</p>

<h1 id="define-initnonzerodictslotsmp-do--">define INIT_NONZERO_DICT_SLOTS(mp) do { \</h1>
<pre><code>(mp)-&gt;ma_table = (mp)-&gt;ma_smalltable;\
(mp)-&gt;ma_mask = PyDict_MINSIZE - 1; \ } while(0)
</code></pre>

<h1 id="define-emptytominsizemp-do----">define EMPTY_TO_MINSIZE(mp) do {   \</h1>
<pre><code>memset((mp)-&gt;ma_smalltable, 0, sizeof((mp)-&gt;ma_smalltable))\
(mp)-&gt;ma_used = (mp)-&gt;ma_fill = 0;\
INIT_NONZERO_DICT_SLOTS(mp); \
    } while(0)
</code></pre>

<p>```</p>

<hr />
<p>Photo By Jason Leaster</p>

<p><img src="/images/img_for_2016_02_04/street.jpg" alt="images" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Int Object in Python]]></title>
    <link href="http://jasonleaster.github.io/blog/2016/02/03/memory-model-of-int-object-in-python/"/>
    <updated>2016-02-03T00:56:31+08:00</updated>
    <id>http://jasonleaster.github.io/blog/2016/02/03/memory-model-of-int-object-in-python</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#preparation" id="markdown-toc-preparation">Preparation</a></li>
  <li><a href="#rules-of-object-in-python" id="markdown-toc-rules-of-object-in-python">Rules of Object in Python.</a></li>
  <li><a href="#firt-glance-at-the-implementation" id="markdown-toc-firt-glance-at-the-implementation">Firt glance at the implementation.</a></li>
  <li><a href="#define-pyobjectheadextra------------" id="markdown-toc-define-pyobjectheadextra------------">define _PyObject_HEAD_EXTRA            \</a></li>
  <li><a href="#define-pyobjectextrainit-0-0" id="markdown-toc-define-pyobjectextrainit-0-0">define _PyObject_EXTRA_INIT 0, 0,</a></li>
  <li><a href="#define-pyobjecthead-------------------" id="markdown-toc-define-pyobjecthead-------------------">define PyObject_HEAD                   \</a>    <ul>
      <li><a href="#initialization-of-pyintobject" id="markdown-toc-initialization-of-pyintobject">Initialization of PyIntObject</a></li>
    </ul>
  </li>
  <li><a href="#define-blocksize------1000-----1k-less-typical-malloc-overhead-" id="markdown-toc-define-blocksize------1000-----1k-less-typical-malloc-overhead-">define BLOCK_SIZE      1000    /* 1K less typical malloc overhead */</a>    <ul>
      <li><a href="#insert-and-delete" id="markdown-toc-insert-and-delete">Insert and Delete</a></li>
      <li><a href="#time-for-hacking" id="markdown-toc-time-for-hacking">Time for Hacking</a></li>
    </ul>
  </li>
</ul>

<h3 id="preparation">Preparation</h3>

<p>Here, we are goint to analysis how Python deal with <code>Int Object</code> in itself.</p>

<p>First of all, we should have a environment which help us to explore the detail of the implementation in <code>Python 2.7</code>. At the same time, our operation shouldn’t influence the origianl Python in your workstation, if you have install Python before.</p>

<p>You can get the source code from offical website of Python. And you will find that there have a file <code>configure</code> in the directory of the source.</p>

<p><em>In the file configure, you can replace all string ‘Python’ with ‘pyLab’. And then move all file prefix with <code>Python</code> into <code>pyLab</code>(mainly in directory Misc/ and Modules)</em></p>

<p>Don’t forget to run the configuration file – configure with the option <code>--prefix=Location where you want the Python which is for lab to install </code></p>

<p>Finally, just run <code>make &amp; make install</code></p>

<p>Repeat myself again, the reason that I move all ‘Python’ into ‘pyLab’ is all for making a difference with the original instance which is official and shouldn’t be influence by any operation from us.</p>

<h3 id="rules-of-object-in-python">Rules of Object in Python.</h3>

<ul>
  <li>Objects are structures allocated on the heap.</li>
  <li>Objects are never allocated statically or on the stack; they must be accessed through special macros and functions only.</li>
</ul>

<!-- more -->

<ul>
  <li>
    <p>An object has a ‘reference count’ that is increased or decreased when a pointer to the object is copied or deleted; when the reference count reaches zero there are no references to the object left and it can be removed from the heap.</p>
  </li>
  <li>
    <p>An object has a ‘type’ that determines what it represents and what kind of data it contains.  An object’s type is fixed when it is created. Types themselves are represented as objects; an object contains a pointer to the corresponding type object.  The type itself has a type pointer pointing to the object representing the type ‘type’, which contains a pointer to itself!).</p>
  </li>
  <li>
    <p>Objects do not float around in memory; once allocated an object keeps the same size and address.  Objects that must hold variable-size data can contain pointers to variable-size parts of the object.  Not all objects of the same type have the same size; but the size cannot change after allocation.</p>
  </li>
  <li>
    <p>Objects are always accessed through pointers of the type ‘PyObject *’.</p>
  </li>
</ul>

<h3 id="firt-glance-at-the-implementation">Firt glance at the implementation.</h3>

<p>``` C++</p>

<p>/*
   There are two basic different type of Object in Python.
   1. PyObject.    (Immutable Object eg: int, string object which’s 
                                size is known when it is creating.)
   2. PyVarObject. (Mutable Object eg: list object which’s size is 
                    unknown when it is creating and support the 
                    operation of deleting and inserting)
                        – notes by Jason Leaster
 */
typedef struct _object {
    PyObject_HEAD
} PyObject;</p>

<p>typedef struct {
    PyObject_VAR_HEAD
} PyVarObject;
```</p>

<p>Actually, PyObject are created by Macro <code>PyObject_HEAD</code></p>

<p>``` C++</p>

<p>[Include/object.h]</p>

<p>…</p>

<h1 id="define-pyobjectheadextra------------">define _PyObject_HEAD_EXTRA            \</h1>
<pre><code>struct _object *_ob_next;           \
struct _object *_ob_prev;
</code></pre>

<h1 id="define-pyobjectextrainit-0-0">define _PyObject_EXTRA_INIT 0, 0,</h1>

<h1 id="define-pyobjecthead-------------------">define PyObject_HEAD                   \</h1>
<pre><code>_PyObject_HEAD_EXTRA                \
Py_ssize_t ob_refcnt;               \
struct _typeobject *ob_type;
</code></pre>

<p>/* 
   There also have some Macro to get the data member of PyObject.
                    – notes by Jason Leaster
 <em>/
#define Py_REFCNT(ob)           (((PyObject</em>)(ob))-&gt;ob_refcnt)
#define Py_TYPE(ob)             (((PyObject<em>)(ob))-&gt;ob_type)
#define Py_SIZE(ob)             (((PyVarObject</em>)(ob))-&gt;ob_size)</p>

<p>…</p>

<p>```</p>

<p>Typically, the Int Object in Python <code>PyIntObject</code> is a <code>immutable object</code>. Once we created the object, we can’t change the value in that object.</p>

<p>Back to our topic, let’s look at the definition of <code>PyIntObject</code>.</p>

<p>``` C++</p>

<p>//[Include/intobject.h]</p>

<p>typedef struct{
    PyObject_HEAD
    long ob_ival;
} PyIntObject;</p>

<p>```</p>

<p>Aha, the <code>PyIntObject</code> is just a simple capsulation of <code>long</code> in C.
This object maintain a long data member.</p>

<p>``` C++</p>

<p>static int
int_compare(PyIntObject <em>v, PyIntObject *w)
{
    /</em>
    You will sigh that “the author of Python is a master in 
    programming”. For efficient, they use <code>register</code> keyword and 
    try to apply for using register to store the local variable.
                            – notes by Jason Leaster.
    */
    register long i = v-&gt;ob_ival;
    register long j = w-&gt;ob_ival;
    return (i &lt; j) ? -1 : (i &gt; j) ? 1 : 0;
}</p>

<p>```</p>

<p>How about the detail of printing a integer in Python ?</p>

<p>``` C++</p>

<p>/* ARGSUSED <em>/
static int
int_print(PyIntObject *v, FILE *fp, int flags)
    /</em> flags – not used but required by interface */
{
    long int_val = v-&gt;ob_ival;
    Py_BEGIN_ALLOW_THREADS
    fprintf(fp, “%ld”, int_val);
    Py_END_ALLOW_THREADS
    return 0;
}</p>

<p>```</p>

<p>There have many others method which are defined in <code>PyNumberMethods</code>. Python programmer can get the information about the object with a data member <code>__doc__</code>, like this:</p>

<p><img src="/images/img_for_2016_02_03/doc.png" alt="images" /></p>

<p>The implementation of that is just a plain text string in <code>Object/intobject.c</code></p>

<p>``` C++</p>

<p>PyDoc_STRVAR(int_doc,
“int(x=0) -&gt; int or long\n\
int(x, base=10) -&gt; int or long\n\
\n\
Convert a number or string to an integer, or return 0 if no arguments\n\
are given.  If x is floating point, the conversion truncates towards zero.\n\
If x is outside the integer range, the function returns a long instead.\n\
\n\
If x is not a number or if base is given, then x must be a string or\n\
Unicode object representing an integer literal in the given base.  The\n\
literal can be preceded by ‘+’ or ‘-‘ and be surrounded by whitespace.\n\
The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to\n\
interpret the base from the string as an integer literal.\n\
»&gt; int(‘0b100’, base=0)\n\
4”);</p>

<p>```</p>

<h3 id="initialization-of-pyintobject">Initialization of PyIntObject</h3>

<p>Python support many different API to construct a <code>PyIntObject</code>.</p>

<p>``` C++</p>

<p>[Include/intobject.h]
…
PyAPI_FUNC(PyObject <em>) PyInt_FromString(char</em>, char<em>*, int);
#ifdef Py_USING_UNICODE
PyAPI_FUNC(PyObject *) PyInt_FromUnicode(Py_UNICODE</em>, Py_ssize_t, int);
#endif
PyAPI_FUNC(PyObject *) PyInt_FromLong(long);
PyAPI_FUNC(PyObject *) PyInt_FromSize_t(size_t);
PyAPI_FUNC(PyObject *) PyInt_FromSsize_t(Py_ssize_t);
…</p>

<p>```</p>

<p>Before we dig into the implementation of the initialization process.
Let’s do a lab.</p>

<p><img src="/images/img_for_2016_02_03/different_address.png" alt="images" /></p>

<p><code>id(object)</code> will returen the address of object in CPython.</p>

<p>Try to answer the following question.</p>

<p>Why int object <code>m</code> and <code>n</code> of value <code>1000</code> have different address?</p>

<p>Why int object <code>x</code> and <code>y</code> of value <code>1</code>    have the same  address?</p>

<p>The answer relate to the mechanism with numbers in Python.</p>

<p><em>In daily programming stuff, small number are used frequently. But large number may used frequent more than small numbers</em></p>

<p>If there isn’t a special mechanism, Python will allocate memory(call malloc() in C) again and again. This stratege isn’t efficient at run time.
So, Python support a mechanism which will create small number only once but not bigger number.</p>

<p>There also have the other question. What means big? What means small?
It’s not clearly in theory. But in the implementation, there have a trade off. People can’t cache all integer number for the limitation of memory(RAM).</p>

<p>``` C++</p>

<p>[Object/intobject]
…
/*
NSMALLPOSINTS:    Numbers of small positive integers number
NSMALLNEGINTS:    Numbers of small negative integers number
        –notes by Jason Leaster
<em>/
#ifndef NSMALLPOSINTS<br />
#define NSMALLPOSINTS           257
#endif
#ifndef NSMALLNEGINTS<br />
#define NSMALLNEGINTS           5
#endif
#if NSMALLNEGINTS + NSMALLPOSINTS &gt; 0
/</em>  References to small integers are saved in this array so that they
    can be shared.
    The integers that are saved are those in the range
    -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).
*/
static PyIntObject *small_ints[NSMALLNEGINTS + NSMALLPOSINTS];
#endif
…</p>

<p>```</p>

<p>According to the implementation, the small number is [-5, 257). You can also modify the source code and recomplie it to change the range of small number, if you would like to.</p>

<blockquote>
  <p>Integers are quite normal objects, to make object handling uniform.
   (Using odd pointers to represent integers would save much space
   but require extra checks for this special case throughout the code.)
   Since a typical Python program spends much of its time allocating
   and deallocating integers, these operations should be very fast.
   Therefore we use a dedicated allocation scheme with a much lower
   overhead (in space and time) than straight malloc(): a simple
   dedicated free list, filled when necessary with memory from malloc().
   block_list is a singly-linked list of all PyIntBlocks ever allocated,  linked via their next members.  PyIntBlocks are never returned to the
   system before shutdown (PyInt_Fini).
   free_list is a singly-linked list of available PyIntObjects, linked
   via abuse of their ob_type members.</p>
</blockquote>

<p>``` C++</p>

<h1 id="define-blocksize------1000-----1k-less-typical-malloc-overhead-">define BLOCK_SIZE      1000    /* 1K less typical malloc overhead */</h1>
<p>#define BHEAD_SIZE      8       /* Enough for a 64-bit pointer */
#define N_INTOBJECTS    ((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyIntObject))</p>

<p>struct _intblock {
    struct _intblock *next;
    PyIntObject objects[N_INTOBJECTS];
};</p>

<p>typedef struct _intblock PyIntBlock;</p>

<p>static PyIntBlock *block_list = NULL;
static PyIntObject *free_list = NULL; // Initliazed by fill_free_list()</p>

<p>```</p>

<h3 id="insert-and-delete">Insert and Delete</h3>

<p>A initialization routine from <code>long type</code> integer number.</p>

<p>``` C++</p>

<p>PyObject *
PyInt_FromLong(long ival)
{
    register PyIntObject *v;
    // try to use small number pool
#if NSMALLNEGINTS + NSMALLPOSINTS &gt; 0
    if (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) {
        v = small_ints[ival + NSMALLNEGINTS];
        Py_INCREF(v);
#ifdef COUNT_ALLOCS
        if (ival &gt;= 0)
            quick_int_allocs++;
        else
            quick_neg_int_allocs++;
#endif
        return (PyObject *) v;
    }
#endif</p>

<p>// if ival is not a small number, create a new instance object.
   if (free_list == NULL) {
       if ((free_list = fill_free_list()) == NULL)
           /*
              fill_free_list() will create a general number pool 
              for PyIntObjects.
              But if there is no memory, return NULL
            <em>/
           return NULL;
   }
   /</em> Inline PyObject_New <em>/
   v = free_list;
   free_list = (PyIntObject *)Py_TYPE(v); 
   // Py_TYPE(ob)  (((PyObject</em>)(ob))-&gt;ob_type) –notes by Jason Leaster
   PyObject_INIT(v, &amp;PyInt_Type);
   v-&gt;ob_ival = ival;
   return (PyObject *) v;
}</p>

<p>```</p>

<h3 id="time-for-hacking">Time for Hacking</h3>
<p>Modify the <code>int_print</code> function in <code>Object/intobject.c</code>.
Here is my modification:</p>

<p>``` C++</p>

<p>/*
 Programmer : Jason Leaster
 Date       : 2016.02.03</p>

<p>Modify from Robert Chen’s code.
 */</p>

<p>tatic int values[10];
static int refcounts[10];</p>

<p>static int
int_print(PyIntObject <em>v, FILE *fp, int flags)
         /</em> flags – not used but required by interface <em>/
{
        // «&lt; modified by Jason Leaster
        PyIntObject</em> intObjectPtr = NULL;
        PyIntBlock* p    = block_list;
        PyIntBlock* last = NULL;</p>

<pre><code>    int count = 0;
    int i = 0;
    while(p != NULL)
    {
        count++;
        last = p;
        p = p-&gt;next;
    }
    
    intObjectPtr = last-&gt;objects;
    intObjectPtr+= N_INTOBJECTS - 1;
        
    printf(" Address @%p\n", v);
    
    for(i = 0; i &lt; 10; i++, --intObjectPtr)
    {
        values[i] = intObjectPtr-&gt;ob_ival;
        refcounts[i] = intObjectPtr-&gt;ob_refcnt;
    }
    
    printf(" Values: ");
    for(i = 0; i &lt; 10; i++)
    {
        printf("%d\t", values[i]);
    }
    printf("\n");

    printf(" refcnt: ");
    for(i = 0; i &lt; 10; i++)
    {
        printf("%d\t", refcounts[i]);
    }
    printf("\n");

    printf(" block_list count: %d\n", count);
    printf(" free_list : %p\n", free_list);

    // &gt;&gt;&gt; Origianl
    long int_val = v-&gt;ob_ival;
    Py_BEGIN_ALLOW_THREADS
    fprintf(fp, "%ld", int_val);
    Py_END_ALLOW_THREADS
    return 0; }
</code></pre>

<p>Tips for debugging:
<code>getrefcount</code> in module <code>sys</code> is helpful to get the reference number of object.</p>

<p>```</p>

<p><img src="/images/img_for_2016_02_03/printout.png" alt="images" /></p>

<hr />

<p>Photo by Jason Leaster, in ChangeDe Hunan
<img src="/images/img_for_2016_02_03/street.jpg" alt="images" /></p>

]]></content>
  </entry>
  
</feed>
